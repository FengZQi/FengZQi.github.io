[{"title":"uboot","path":"/2025/06/10/uboot/","content":"uboot编译# ARCH 指定架构 CROSS_COMPILE 指定交叉编译器 # 最后指定命令 # distclean：清除工程 # mx6ull_14x14_ddr512_emmc_defconfig：配置文件# -j12：12核编译make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distcleanmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_14x14_ddr512_emmc_defconfigmake V=1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j12 启动 命令？ help ? xxx bootinfo printenv print setenv | saveenv修改 新建 删除 内存操作md 显示# .b byte 1字节 .w word 2字节 .l long 4字节；后面数据长度为十六进制个上述对象长度md[.b, .w, .l] address [# of objects]= md.b 0x80000000 1480000000: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 .ELF............80000010: 03 00 28 00 ..(. nm 修改= nm.l 8000000080000000: 464c457f ? 1234567880000000: 12345678 ?80000000: 12345678 ? q= md.l 80000000 180000000: 12345678 xV4. mm 修改地址会自增 mw 填充mw [.b, .w, .l] address value [count] cp 拷贝cp [.b, .w, .l] source target count cmp 比较cmp [.b, .w, .l] addr1 addr2 count 网络操作Ubuntu主机VLAN地址：192.168.1.23 Ubuntu主机ETH地址：192.168.1.30 setenv ipaddr 192.168.1.48setenv ethaddr b8:ae:1d:01:00:00setenv gatewayip 192.168.1.1setenv netmask 255.255.255.0setenv serverip 192.168.1.23saveenv ping dhcp dhcp获取的动态IP会覆盖静态IP，保存到环境变量； dhcp还会通过TFTP来启动Linux内核 nfsnfs [loadAddress] [[hostIPaddr:]bootfilename]# DRAM地址 nfs 80800000 192.168.1.23:/home/zq/0_Linux/nfs/zImage :question: 连接不到宿主机nfs服务器 宿主机不支持nfsv2 问题排查： kernel中可以通过nfs挂载到宿主机目录:arrow_right:nfs可以使用 宿主机配置nfsv2使能:arrow_right:未生效，可能是wsl2的内核,需要更换内核，目前使用的是wsl2作为虚拟机，更换5.15.129-0515129-generic内核wsl2还可以使用吗:grey_question: zq@ZQi:~$ uname -r5.15.167.4-microsoft-standard-WSL2+zq@ZQi:~$ sudo cat /proc/fs/nfsd/versions+3 +4 +4.1 +4.2 kernel中可以配置nfsv3版本:arrow_right:在kernel初始化阶段中挂载rootfs时配置nfsv3 setenv bootargs console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.1.23:/home/zq/0_Linux/nfs/rootfs,v3,proto=tcp rw ip=192.168.1.48:192.168.1.23:192.168.1.1:255.255.255.0::eth0:off 总结：uboot由于nfsv2不能使用nfs，通过bootargs在kernel中设置nfs版本为3。 tftp# 宿主机tftp文件夹路径：/home/zq/0_Linux/tftp# tftp不需要完整路径，只要文件名tftpboot [loadAddress] [[hostIPaddr:]bootfilename] :question:TFTP传输时，小文件可以下载，大文件例如zImage超时 解决方案：通过设置环境变量tftpblocksize大小为512、1024、1234等，都可以对上一个block进行确认；默认大小为1468 :grey_question:下载到地址上的数据不对应，缺失了 没有缺失 外存操作 eMMC SD = mmc listFSL_SDHC: 0 (SD)FSL_SDHC: 1 (eMMC)# mmc read eMMC - DRAM 0x80800000 单位注意全部是十六进制mmc read addr blk# cnt# mmc write DRAM - eMMC# 千万不要写 SD 卡或者 EMMC 的前两个块(扇区)，里面保存着分区表！mmc write addr blk# cnt= mmc dev 1 0switch to partitions #0, OKmmc1(part 0) is current device= versionU-Boot 2016.03-g0ae7e33 (Aug 14 2022 - 19:42:45 +0800)arm-poky-linux-gnueabi-gcc (GCC) 5.3.0GNU ld (GNU Binutils) 2.26.0.20160226= tftp 80800000 u-boot.imxUsing FEC1 deviceTFTP from server 192.168.1.23; our IP address is 192.168.1.50Filename u-boot.imx.Load address: 0x80800000Loading: #################################### 754.9 KiB/sdoneBytes transferred = 363520 (58c00 hex)= mmc write 80800000 2 32E = mmc partconf 1 1 0 0 // 分区配置，EMMC需要这一步= reset= versionU-Boot 2016.03 (Jun 11 2025 - 14:49:04 +0800)arm-linux-gnueabihf-gcc (Linaro GCC 4.9-2017.01) 4.9.4GNU ld (Linaro_Binutils-2017.01) 2.24.0.20141017 Linaro 2014_11-3-git FAT格式文件系统操作fatinfo 查询指定MMC设备分区的文件系统信息fatinfo interface [dev[:part]]fatinfo mmc 1:1 fatls 查询目录和文件信息fatls interface [dev[:part]] [directory]fatls mmc 1:1 fstype 查看分区文件系统格式= fstype mmc 1:0Failed to mount ext2 filesystem...** Unrecognized filesystem type **= fstype mmc 1:1fat= fstype mmc 1:2ext4 fatload 读指定文件到DRAMfatload interface [dev[:part] [addr [filename [bytes [pos]]]]]fatload mmc 1:1 80800000 zImage fatwrite 写DRAM数据到MMC# 需要配置开发板配置头文件#define CONFIG_FAT_WRITE /* 使能 fatwrite 命令 */fatwrite interface dev[:part] addr filename bytesfatwrite mmc 1:1 80800000 zImage 6788f8 EXT格式文件系统操作uboot有ext2和ext4两种格式的文件系统 ext2load、ext2ls、ext4load、ext4ls BOOT操作bootz启动Linux，需要将Linux镜像拷贝到DRAM；源：NFS、TFTPeMMC、NANDSD bootz [addr [initrd[:size]] [fdt]]addr: Linux镜像文件在DRAM地址initrd: initrd文件在DRAM地址，不使用时用 ‘-’fdt: 设备树文件在DRAM地址# 通过tftp启动= tftp 80800000 zImageFEC1 Waiting for PHY auto negotiation to complete..... doneUsing FEC1 deviceTFTP from server 192.168.1.23; our IP address is 192.168.1.50Filename zImage.Load address: 0x80800000Loading: ########################################################## 530.3 KiB/sdoneBytes transferred = 6785480 (6789c8 hex)= tftp 83000000 imx6ull-14x14-emmc-4.3-800x480-c.dtbUsing FEC1 deviceTFTP from server 192.168.1.23; our IP address is 192.168.1.50Filename imx6ull-14x14-emmc-4.3-800x480-c.dtb.Load address: 0x83000000Loading: #### 453.1 KiB/sdoneBytes transferred = 39459 (9a23 hex)= bootz 80800000 - 83000000 # 通过eMMC启动fatload mmc 1:1 80800000 zImagefatload mmc 1:1 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtbbootz 80800000 - 83000000 bootm 与bootz类似 启动uImagezImage uImage zImage是内核压缩镜像 uImage是zImage加了个uboot头部，专用于uboot这个启动器的 boot 读取bootcmd启动 其他 reset go addr [arg …] 到DRAM中运行 run xxxcmd 可以设置不同情况的启动cmd，通过run来调用不同的cmd mtest 内存测试 U-Boot 工程uboot目录 arch架构相关 board开发板相关 configsdefconfig配置文件 make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_14x14_ddr512_emmc_defconfig .u-boot.xxx_cmd文件 .u-boot.bin.cmd # u-boot.nodtb.bin - u-boot.bincmd_u-boot.bin := cp u-boot-nodtb.bin u-boot.bin .u-boot.nodtb.bin.cmd # objcopy ELF文件 u-boot - bin文件 u-boot.nodtb.bincmd_u-boot-nodtb.bin := arm-linux-gnueabihf-objcopy --gap-fill=0xff -j .text -j .secure_text -j .rodata -j .hash -j .data -j .got -j .got.plt -j .u_boot_list -j .rel.dyn -O binary u-boot u-bootnodtb.bin .u-boot.cmd # 链接 目标文件build-in.o 链接脚本u-boot.ldscmd_u-boot := arm-linux-gnueabihf-ld.bfd -pie --gc-sections -Bstatic -Ttext 0x87800000 -o u-boot -T u-boot.ldsarch/arm/cpu/armv7/start.o --start-group arch/arm/cpu/built-in.oarch/arm/cpu/armv7/built-in.o arch/arm/imx-common/built-in.oarch/arm/lib/built-in.o board/freescale/common/built-in.oboard/freescale/mx6ull_alientek_emmc/built-in.o cmd/built-in.ocommon/built-in.o disk/built-in.o drivers/built-in.odrivers/dma/built-in.o drivers/gpio/built-in.o .../build-in.odrivers/usb/musb-new/built-in.o drivers/usb/musb/built-in.odrivers/usb/phy/built-in.o drivers/usb/ulpi/built-in.o fs/built-in.olib/built-in.o net/built-in.o test/built-in.o test/dm/built-in.o --end-group arch/arm/lib/eabi_compat.o -L /usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linuxgnueabihf/4.9.4 -lgcc -Map u-boot.map .u-boot.imx.cmd cmd_u-boot.imx := ./tools/mkimage -nboard/freescale/mx6ull_alientek_emmc/imximage.cfg.cfgtmp -T imximage -e 0x87800000 -d u-boot.bin u-boot.imx u-boot.xxx文件u-boot：编译出来的 ELF 格式的 uboot 镜像文件。 u-boot.bin：编译出来的二进制格式的 uboot 可执行镜像文件。 u-boot.cfg： uboot 的另外一种配置文件。 u-boot.imx： u-boot.bin 添加头部信息以后的文件， NXP 的 CPU 专用文件。 u-boot.lds：链接脚本。和armcpu目录下的基本一样 u-boot.map： uboot 映射文件，通过查看此文件可以知道某个函数被链接到了哪个地址上。 u-boot.srec： S-Record 格式的镜像文件。 u-boot.sym： uboot 符号文件。 u-boot-nodtb.bin：和 u-boot.bin 一样， u-boot.bin 就是 u-boot-nodtb.bin 的复制文件。 .config文件make xxx_defconfig — .config # 使能功能CONFIG_CMD_BOOTM=y# cmd/Makefile1 ifndef CONFIG_SPL_BUILD2 # core command3 obj-y += boot.o4 obj-$(CONFIG_CMD_BOOTM) += bootm.o5 obj-y += help.o6 obj-y += version.oobj-y中包含了所有要编译到内核的.o文件obj-n不编译0bj-m编译成模块 搜索 浏览 Makefile"},{"title":"imx6ul刷写","path":"/2025/06/06/imx6ul刷写/","content":"裸机开发Windows环境 100ask_imx6ull_flashing_tool_v4.0.exe 刷到RAM中运行，掉电失效 刷到EMMC :question:目前效果只是刷到RAM，未刷到EMMC uuu # 刷到RAMuuu.exe xxx.imx # 刷到EMMC :question:刷写卡住了，RAM中可以运行程序，但未刷到EMMC mfgtool :question:目前不知道如何刷裸机程序 Linux环境 imxdownload # 将bin文件加上特定格式的前缀文件，以一定的偏移量刷到SD卡中# 设置SD卡启动方式 :question:wsl2识别不了TF卡，只能识别USB 解决：配置WSL2 Ubuntu24.04 连接USB设备 识别SD卡_wsl2 usb 重新编译wsl2内核，进行替换 git clone https://github.com/microsoft/WSL2-Linux-Kernel.git# 切换分支 # uname -r 会输出当前内核版本 5.15.167.4-microsoft-standard-WSL2# cut -d- -f1 会提取内核版本中的第一部分 5.15.167.4cd WSL2-Linux-Kernelgit checkout linux-msft-wsl-$(uname -r | cut -d- -f1)# 修改内核编译选项，编译WSL内核make menuconfig KCONFIG_CONFIG=Microsoft/config-wsl# Device Drivers - USB support - Support for Host-side USB ，选中 USB Mass Storage supportmake -j$(nproc) bzImage KCONFIG_CONFIG=Microsoft/config-wsl# 修改wsl配置文件.wslconfig[wsl2]kernel=bzImage path # *\\\\*\\\\*\\\\bzImage uuu 同上 mfgtool 裸机开发总结windows环境下exe刷写方便，需要配置好工具链； linux环境下工具链配置方便，没有ui刷写工具； 目前linux工具链已配置，先用uuu刷到RAM :question:imx header生成：1、网上header 加上 bin（未成功）2、imxdownload 会生成imx，同时不写入到SD卡中 Linux驱动开发Windows环境 100ask_imx6ull_flashing_tool_v4.0.exe mfgtool Linux环境","tags":["刷写"]},{"title":"编译&链接","path":"/2025/06/05/编译-链接/","content":"编译链接指令 -o ：指定输出文件名。 -c：只编译，不链接。 -E：只预处理，不编译。 -S：只编译，不汇编。 -I ：指定头文件搜索路径。 -L ：指定库文件搜索路径。 -l ：指定链接的库文件。 -g：生成调试信息。 -O：优化代码，-O1、-O2、-O3表示不同级别的优化 -shared -Ttext 指定链接地址 0x87800000 -lxxx -L path 指定链接xxx静态库，以及指出库路径 -fno-builtin 不使用内建函数 例子 gcc -shared -o libmylib.so file1.o file2.oarm-linux-gnueabihf-gcc -g -c led.s -o led.oarm-linux-gnueabihf-ld -Ttext 0X87800000 led.o -o led.elfLIBPATH := -lgcc -L /usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/lib/gcc/arm-linux-gnueabihf/4.9.4 其他objcopy 格式转换 “-O”选项指定以什么格式输出 “binary”表示以二进制格式输出 “-S”表示不要复制源文件中的重定位信息和符号信息 “-g”表示不复制源文件中的调试信息 arm-linux-gnueabihf-objcopy -O binary -S -g led.elf led.bin objdump 反汇编 “-D”选项表示反汇编所有的段 arm-linux-gnueabihf-objdump -D led.elf led.dis"},{"title":"Make&CMake","path":"/2025/06/04/Make-CMake/","content":"Make语法# 规则格式目标…... : 依赖文件集合……\t命令 1\t命令 2\t……main : main.o input.o calcu.o\tgcc -o main main.o input.o calcu.o\t# 赋值符号# 1、= 变量的真实值取决于它所引用的变量的最后一次有效值# 2、:= 不会使用后面定义的变量，只能使用前面已经定义好的# 3、?= 如果变量前面赋过值，就用前值；否则用当前值# 4、+= 追加# 通配符# 1、% 长度任意的非空字符串# 伪目标 将clean声明为伪目标，防止目录中有同名目标的文件，clean后面的命令可能不能正确执行.PHONY : cleanclean rm *.o rm main # 函数 $(subst from,to,text) # 字符替换 $(subst zzk,ZZK,my name is zzk) $(patsubst pattern,replacement,text) # 模式字符串替换 $(patsubst %.c,%.o,a.c b.c c.c) $(dir names…) # 目录 $(notdir names…)# 去除文件中目录部分 $(foreach var, list,text)# 循环 $(wildcard PATTERN…)# 通配符 自动化变量 描述 $@ 规则中的目标集合，在模式规则中，如果有多个目标的话，“$@”表示匹配模式中定义的目标集合。 $% 当目标是函数库的时候表示规则中的目标成员名，如果目标不是函数库文件，那么其值为空。 $ 依赖文件集合中的第一个文件，如果依赖文件是以模式(即“%” )定义的，那么“$”就是符合模式的一系列的文件集合。 $? 所有比目标新的依赖目标集合，以空格分开。 $^ 所有依赖文件的集合，使用空格分开，如果在依赖文件中有多个重复的文件， “$^”会去除重复的依赖文件，值保留一份。 $+ 和“$^”类似，但是当依赖文件存在重复的话不会去除重复的依赖文件。 $* 这个变量表示目标模式中”%”及其之前的部分，如果目标是 testa.test.c，目标模式为 a.%.c，那么“$*”就是 testa.test。","categories":["构建工具"]},{"title":"Markdown","path":"/2025/06/03/Markdown/","content":"Markdown语法 颜色 font color=red这段文字是红色的！/fontp style=color:blue这段文字是蓝色的。/p 这段文字是红色的！ 这段文字是蓝色的。 框 ``test test`` test test"},{"title":"STM32+FreeRTOS(1)环境搭建","path":"/2025/06/03/STM32-FreeRTOS/","content":"STM32F103环境搭建编译arm-none-eabi-gcc 项目构建CMake 项目代码 启动文件 .\\Keil_v5\\ARM\\Pack\\Keil\\STM32F1xx_DFP\\2.4.1\\Device\\Source\\ARM Keil对应板子的固件库中，startup_stm32f10x_hd.S专用于keil的汇编启动代码，如果用gcc-arm编译需要找gcc-arm的汇编文件 以下是keil汇编启动代码： 配置向量表 初始化堆栈 初始化时钟、跳转到main 链接脚本 STM32F103VETX_FLASH.ld是一个链接脚本文件，它告诉编译器相关的编译后的可执行代码，内存变量，中断向量，链接在哪个存储区。 CubeMax可以生成；网上也有 固件库STM32F10x_FWLib 系统文件 调试 openocd 架构 OpenOCD 本身是一个“服务器”，启动后监听端口（通常是 3333）等待客户端（如 GDB）连接。 其组成包括： 组件 说明 Interface 配置 定义与电脑连接的调试器设备（如 ST-Link、J-Link） Target 配置 定义目标芯片的信息和内存布局（如 STM32F103） GDB 连接端口 默认 3333，供调试器如 arm-none-eabi-gdb 连接 Telnet 端口 默认 4444，可手动控制 OpenOCD 会话 configurations: [ cwd: $workspaceRoot, executable: $cwd/build/MQTTPrj.elf, name: cmsis-dap, request: launch, type: cortex-debug, svdFile: .pack/Keil/STM32F1xx_DFP.2.4.1/SVD/STM32F103xx.svd, servertype: openocd, configFiles: [ interface/cmsis-dap.cfg, target/stm32f1x.cfg ], searchDir: [], runToEntryPoint: main, showDevDebugOutput: none 依赖文件 OpenOCD 运行时需要两个配置文件（可以通过 -f 参数加载）： a. 接口配置文件（interface.cfg） 告诉 OpenOCD 使用哪种硬件调试器（如 ST-Link、J-Link）： -f interface/stlink.cfg b. 目标配置文件（target.cfg） 告诉 OpenOCD 连接的是哪种 MCU 芯片（如 STM32F1、STM32F4）： -f target/stm32f1x.cfg c. SVD 文件（可选，用于 IDE) SVD（System View Description） 是 ARM CMSIS 标准的芯片寄存器描述文件，OpenOCD 本身不依赖 SVD 文件，但调试器（如 VS Code + Cortex-Debug）可能会用到。 刷写 @echo offcd ./buildecho %cd%set HEXName=MQTTPrjopenocd -f interface/cmsis-dap.cfg -f target/stm32f1x.cfg -c program %HEXName%.hex verify reset exitif errorlevel 1 ( echo ****flash failed!****) else ( echo ****flash success!****) 环境配置问题 gcc编译需要修改core_cm3.c文件 ……"},{"title":"MQTT","path":"/2025/05/30/MQTT/","content":"MQTTtest CONNECT Keep Alive:1.5倍超时 CONNACK PUBLISH QoS 0 - 报文标识符则无 PUBACKQoS1 PUBREC PUBREL PUBCOMPQoS2 Client\t--PUBLISH--\tServer --PUBREC-- --PUBREL-- --PUBCOMP-- SUBSRCIBE SUBACK UNSUBSCRIBE UNSUBACK PINGREQ PINGRESP DISCONNECT Value Reason Code Name Sent By Description 0x00 Normal disconnection 客户端、服务端 表示连接正常关闭，因此服务端不会发布遗嘱消息。 0x04 Disconnect with Will Message 客户端 连接正常关闭，但客户端希望服务端仍然发布遗嘱消息。 0x81 Malformed Packet 客户端、服务端 表示收到了无法按照协议规范正确解析的控制报文，在 MQTT 中我们将这类报文称为畸形报文。 0x82 Protocol Error 客户端、服务端 协议错误通常指控制报文在按照协议规范解析以后才能发现的错误，包括包含协议不允许的数据、行为与协议要求不符等等。比如客户端在一个连接内发送了两个 CONNECT 报文。 0x8D Keep Alive timeout 服务端 服务端在超过 1.5 倍的 Keep Alive 时间内没有收到任何报文，因此关闭了连接。 0x8E Session taken over 服务端 另一个更新的使用了且相同的 Client ID 的连接被建立，导致服务端关闭了此连接。 0x93 Receive Maximum exceeded 客户端、服务端 表示对端同时发送的 QoS 0 的 PUBLISH 报文数量超过了连接时设置的接收最大值。 0x94 Topic Alias invalid 客户端、服务端 表示主题别名不合法。比如 PUBLISH 报文中的主题别名值为 0 或者大于连接时约定的最大主题别名。 0x95 Packet too large 客户端、服务端 表示报文超过了连接时约定的最大允许长度。 0x98 Administrative action 客户端、服务端 表示连接因为管理操作而被关闭，比如运维人员在服务端后台踢除了客户端连接。 0x9C Use another server 服务端 表示客户端应该临时切换到另一个服务器。如果另一个服务器不是客户端已知的，那么还需要配合 Server Reference 属性一起使用，以告知客户端新的服务端的地址。 0x9D Server moved 服务端 表示客户端应该永久切换到另一个服务器。如果另一个服务器不是客户端已知的，那么还需要配合 Server Reference 属性一起使用，以告知客户端新的服务端的地址。","tags":["MQTT"]},{"title":"link","path":"/2025/05/29/link/","content":"链接全局符号表$ readelf -s xxx/xxx.so 全局偏移量表GOT在一个动态库中存在 2 个GOT表，分别用于重定位变量符号(section名称：.got)和函数符号( section 名称：.got.plt)。 在一个动态库文件中，有两个特殊的段(.rel.dyn和.rel.plt)来告诉链接器：.got和.got.plt这两个表中，有哪些符号需要进行重定位 【图片+代码】：Linux 动态链接过程中的【重定位】底层原理-腾讯云开发者社区-腾讯云 动态加载到内存中后，linker重定位一些符号，依赖文件根据相对地址查找got、plt找到地址","tags":["系统构建"],"categories":["系统构建"]},{"title":"Hexo教程","path":"/2025/05/29/test-blog-website/","content":"教程hexo命令文档 | Hexo # generate static files$ hexo generate(g)# deploy to remote sites$ hexo deploy(d) 页面创建$ hexo new page pagename 分类和标签页面可以使用此方式创建 分类与标签分类创建 $ hexo new page categories 修改md文件，增加categories属性 title: 分类date: 2025-05-29 10:56:43type: categories 文章添加categories属性 categories:- cate1- cate2 - cate2.1 标签创建 $ hexo new page categories 修改md文件，增加tags属性 title: 标签date: 2025-05-29 10:56:43type: tags 文章添加tags属性 tags:- tag1- tag2- [tag3, tag4] 主题Stellar","tags":["教程"],"categories":["网站教程"]}]